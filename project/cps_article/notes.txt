## Intro: ##

Claim: Plotkin's lambda value calculas is incomplete when reasoning BetaEta-transformations on programs in CPS.

Goal to prove claim:  Derive a complete extension to form a CPS tranformation and also to convert it back or an un-CPS
transformation.  The CPS transformation would then define the language of CPS terms closed under BetaEta-transformations.  The
un CPS tranformation would help to derive a set of axioms[rules] such that any equation between source programs would be provable 
if the BetaEta-transformation can prove the rule between CPS programs.

## Section One - Compiling with CPS ## 
The Fischer Reymolds CPS transformation is used in most higher order functional languages.  CPS transformed programs will then be
processed through a series of local transformation. For example, in practice loop unrolling, procedure inlining, and partial evaluation
are commonly used.   Relating to lambda calculus, sequences of Beta- and Eta- reductions are used.  If there exists a correlation between
known transformations of source programs and the optimizations or reductions on CPS programm then optizations of these source programs
could be reported in terms of the original program rather than the CPS version.

Which set of axioms that extend the call by value lambda calculus can prove that for pairs of by value expressions[M,N] they are equal 
when both are transformed using CPS is provable for by the by value and by name lambda calculus.   The canonical form of CPS programs and 
an un CPS tranformations which maps the canonical form of CPS programs back to its original language would give the desired set of axioms 
when studying the relationship between the CPS and un CPS tranformations.

## Section Two - Terminology and Notation of the lambda calculus (Either after history or after Section One)  ## 
Term - value or application [V | (E1 E1)]
Value - variables drawn from set of Vars or lambda abstractions (lambda x . M)[ the variable x is bound in M)
Variables that are not bound by a lambda-abstraction are denoted as free.  FV(M) defined as the set of free variables in a term
M[x := N] - capture free substitution.  
    E.g. (lambda x . x z)[z := (lambda y . x)] = (lambda u . u (lambda y . x) )
A context, C, is a term with a "hole", [], in place of one subexpression.
Filling said context, C, with an expression M yields the term C[M], possibly capturing some free variables of M in the process.
    E.g. Fill (lambda x . x []) with (lambda y . x) = (lambda x . x (lambda y . x) ) 

Lambda Calucli:
- An equational theory over Lambda  with a finite number of axiom schemas and inference rules.
- Most common reductions:
    ( (lambda x . M ) N ) -> M[x := N]   (Beta reduction)
    ( (lambda x . M ) V ) -> M[x := V]   (Beta reduction [by-value])
    lambda x . M x -> M x not in FV(M)   (Eta reduction)
    lambda x . V x -> V x not in FV(V)   (Eta reduction [by-value])
- Beta reduction generates the theory lambda,
- Beta reduction generates the theory lambda [by-value],
- union of Beta and Eta reductions generates the theory lambda Beta-Eta
- lambda A refers to the theory generated by a set of axioms A.

Semantics:
- A program is a term with no free variables.  

Observational Equivalence:
- Two expressions are observational equivalent if for all contexts such that when filling a given context with either expression 
is a program and the evaluation of the two expressions are either both defined or both undefined.
- The soundness of extending lambda and by value lambda calculi with the eta reductions depends on the given context. It is sound
with respect to call by value observational equivalence for Lambda.  In a typed setting, a by value eta reduction is sound, 
independent of how parameters are passed.  By name eta reductions are only sound in a typed language that does not permit the
observation of the termination behavior of higher typed expressions.
 
## Section Three - History of CPS transformation (May put first after introduction) ## 
- Tranforming programs to continuation passing style appeared in the mid 1960s. It was not until 1972 when Fischer and Reynolds implemented
a practical implementation.  Fischer studied two implementations: a heap based retention strategy and a stack based deletion strategy.  Fischer
concluded that, "no real power is lost in restricting oneself to a deletion strategy implementation, for any program can be translated into
an equivalent one which will work correctly under such an implementation". Reynolds investigated definitional interpreters for higher-order
languages.  As a result, Reynolds developed the ability to transform an interpreter so that it did not need to distinguish whether the 
parameter passing technique is call-by-value or call-by-name.  The main disadvantage of the Fischer CPS transformation is the large
number of redexes it introduces in the output which then complicated the reasoning about CPS programs.  The new redexes were referred to as
administrative redexes by Plotkin.  All practical transformations can be summarized to a two pass CPS transformation.  Firstly, mark the new 
lambda abstractions in the output of the Fischer CPS to identify administrative redexes.  Then, reduce all administrative redexes. The resultant
output of all practical CPS transformations will be very compact. 

## Section Four - Formalization of the problem (May merge with Section One) ## 
The problem lies in that by name beta reductions are provable on more equations on CPS terms than that of by value beta reductions.  However,
The effect on eta reductions is unknown. The goal is to remedy this situation by deriving a set of reductions such that: for any set of terms
that are contextually equivalent given a set of axioms for a by value labmda calculus, and if we apply the beta eta reductions to them, then 
they will remain contextually equivalent. 

## Section Five - CPS language and properties; definition of new CPS transformation ## 
A one pass CPS transformation would be a composite transformation of the modified Fischer transformation and the normalized 
beta and eta reductions.  The given one pass transformation will symbolically evaluate redexes by lifting them to base of the 
program. Aplications of values to values inside the abstractions will take the evaluation contexts with respect to the closest
lambda abstraction. The resulting transformation will be a parameterized context such that the parameter will be the continuation 
of the program. 

## Section Six - un CPS and relation to CPS ## 
''The inverse CPS transformation and its relationship to the CPS transformation.
The inverse of the CPS transformation can simply be described as the evaluation context of the continuation of the CPS transformation.
The un CPS transformation can not be a full inverse of the CPS transformation since:  some terms in the resultant transformation are a
mapping of multiple terms, and some are not the mapping of any term.  

## Section Seventh - Main results; the extension of the by value lambda calculus and its completeness ## 
Through the use of the partial inverse of the CPS transformation the set of axioms for a by value lambda calculus can be derived such that
the set is complete for beta eta reasoning about CPS programs.  The set of beta and eta reductions is sound with respect to the observational
equivalence of the terms of a CPS transformation.

## Section Eighth - Relevance and future research (Conclusion of summary) ## 
The extension was found to be sound for beta eta reasonaing about typed CPS programs.  For dynamically typed languages the derived calculus
was unsound since it included the by value eta transformation rule.  Languages that have control operators similar to scheme are still sound
with respect to observational equivalence.
