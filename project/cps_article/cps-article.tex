\input{../style/cs421_project_style.tex}
\usepackage{algorithm}
\usepackage{listings}
%\usepackage{algpseudocode}
\usepackage{graphicx,amssymb,amsmath}
\usepackage{epstopdf}
\usepackage{setspace}
\sloppy

\oddsidemargin 0in
\evensidemargin 0in
\textwidth 6.5in
\topmargin -0.5in
\textheight 9.0in

\begin{document}

\def \cps {continuation passing style }

\solution{Dan McQuillan}{\today}{CPS article summary}{Summer 2015}

\pagestyle{myheadings}  % Leave this command alone
	 	
\doublespacing
% introduction
Felleisen and Amr claim that Plotkin's lambda calculus is incomplete when reasoning Beta-Eta transformations on programs in \cps.  In order to prove the claim, they derived a complete extension to form a \cps transformation and an inverse \cps transformation.  The \cps transformation would then define the language of \cps terms closed under Beta-Eta transformations.  The inverse \cps transformation would help to derive a set of axioms such that any equation between source programs would be provable if the BetaEta-transformation can prove the rule between \cps programs.

%section three
%Transforming programs to \cps appeared in the mid 1960s. It was not until 1972 that Fischer and Reynolds implemented a practical implementation. Fischer studied two implementations: a heap based retention strategy and a stack based deletion strategy. He then concluded that, "no real power is lost in restricting oneself to a deletion strategy implementation, for any program can be translated into an equivalent one which will work correctly under such an implementation." Reynolds investigated definitional interpreters for higher-order languages. As a result, Reynolds developed the ability to transform an interpreter so that it did not need to distinguish whether the parameter passing technique is call by value or call by name. The main disadvantage of the Fischer \cps transformation is the large number of redexes it introduces in the output, which then complicated the reasoning about \cps programs. The new redexes were referred to as "administrative redexes" by Plotkin. All practical transformations can be summarized to a two pass \cps transformation. Firstly, mark the new lambda abstractions in the output of the Fischer \cps to identify administrative redexes. Then, reduce all administrative redexes. The resultant output of all practical \cps transformations will be very compact.

% section two
%The language behind the lambda calculus consists of variables, lambda abstractions, and applications. A term is a value or application of expression.  Values are variables that are drawn from a set of variables or lambda abstractions. Variables that do not have a binding by a lambda abstraction can be viewed as a free variable.  Lambda calculi, in general, represent an equational theory over Lambda with a finite number of axiom schemas and inference rules. The Beta reduction, for both by value and by name, generates the theory lambda.

Observational equivalence is used to prove that the optimization of a program is only a more efficient expression, such that a developer can not notice discrepancies between the program and the optimized version. Two expressions are observationally equivalent if the filling of each context results in a program and the evaluations of the given programs are both either defined or undefined.

The soundness of extending Lambda and, by value lambda calculi with the eta reduction, depends on the given context. It is sound with respect to call by value observational equivalence of Lambda. In a typed setting, a by value eta reduction is sound, independent of how parameters are passed. By name eta reductions are only sound in a typed language that does not permit the observation of the termination behavior of higher type expressions.

% section one
%The Fischer Reynolds \cps transformation is used in most higher order functional languages. Continuation passing style transformed programs will then be processed through a series of local transformations. In practice, optimizations, such as loop unrolling, procedure inlining, and partial evaluation are commonly used. Relating to lambda calculus, sequences of beta and eta reductions are used.  If there exists a correlation between known transformations of source programs and the optimizations or reductions on continuation passing style programs, then optimizations of these source programs could be reported in terms of the original program, rather than the \cps version.

The question asked is: which set of axioms that extend the call by value lambda calculus can prove that, for pairs of by value expressions, they are equal when both are transformed using \cps is provable for by value and by name lambda calculi.  In order to find this set of axioms, a \cps transformation that products the smallest possible canonical form of all known \cps transformations, and an inverse \cps transformation to output the canonical representation in the language of the original program must both be found.  After finding these \cps transformation and its inverse, the correlation between them can then be studied to derive the desired set of axioms.

% section four
The problem lies in that by name beta reductions are provable for more equations on \cps terms than that of by value beta reductions.  However, the effect on eta reductions is unknown. The goal is to remedy this situation by deriving a set of reductions such that: for any set of terms that are contextually equivalent given a set of axioms for a by value lambda calculus, if we apply the beta eta reductions to them, will remain observationally equivalent.

% section five
A one pass \cps transformation would be a composite transformation of the modified Fischer transformation and the normalized beta and eta reductions.  The given one pass transformation will symbolically evaluate redexes by lifting them to base of the program. Applications of values to values inside the abstractions will take the evaluation contexts with respect to the closest lambda abstraction. The resulting transformation will be a parameterized context, such that the parameter will be the continuation of the program.

% section six
The inverse of the \cps transformation can simply be described as the evaluation context of the continuation of the \cps transformation. The un-\cps transformation can not be a full inverse of the \cps transformation since:  some terms in the resultant transformation are a mapping of multiple terms and some are not the mapping of any term.

% section seven
Through the use of the partial inverse of the \cps transformation the set of axioms for a by value lambda calculus can be derived, such that the set is complete for beta eta reasoning about \cps programs.  The set of beta and eta reductions is sound with respect to the observational equivalence of the terms of a \cps transformation.

%section eight
The extension was found to be sound for beta eta reasoning about typed \cps programs.  For dynamically typed languages the derived calculus was unsound, since it included the by value eta transformation rule.  Languages that have control operators similar to scheme are still sound with respect to observational equivalence.

I mainly enjoyed the paper since it gave a sufficient introduction to both \cps and Plotkin's lambda calculus as well as other forms of \cps that have been implemented. In their conclusion I also appreciated that they made references to languages and how their extension would relate to them.  I thought the paper gave a sound case towards the extension of Plotkin's lambda calculus to support beta eta tranformations on continuation passing style programs.  They made their case more robust by proving that the transformations would then be bidirectional before they would arrive at their desired set of axioms to add to Plotkin's calculus.



\end{document}

