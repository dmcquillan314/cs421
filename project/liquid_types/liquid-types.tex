\input{../style/cs421_project_style.tex}
\usepackage{algorithm}
\usepackage{listings}
%\usepackage{algpseudocode}
\usepackage{graphicx,amssymb,amsmath}
\usepackage{epstopdf}
\usepackage{setspace}
\sloppy

\oddsidemargin 0in
\evensidemargin 0in
\textwidth 6.5in
\topmargin -0.5in
\textheight 9.0in

\begin{document}

\solution{Dan McQuillan}{\today}{Liquid Types article}{Summer 2015}

\pagestyle{myheadings}  % Leave this command alone
	 	
\doublespacing		
		
% introduction
The verification of low level programs can prove to be challenging due to the presence of mutable state, pointer arithmetic, and unbounded heap-allocated data structures. Verification of these programs is done through the use of dependent refinement types.  Each program variable and expression is represented as a triple of the expression or variable, a conventional type (such as int or bool), and a refinement predicate.

Current implementations of verification rely on a large amount of annotations that would need to be placed in the source files. The presented software, CSolve, is a proposed way to automate this process which is based on the concept of liquid types. Liquid types combine refinement types with three elements to automate verification:

\begin{enumerate}
	\item First, associating the refinement types with heap locations and tracking the locations referenced by pointers.
	\item Second, adding constructs which allow strong updates to the types of heap locations so that the system can verify the correct initialization of newly-allocated regions of memory.
	\item Third, utilize refinement type inference to automatically verify important safety properties without extenuous amounts of annotations.
\end{enumerate}

% Architecture, use and availability

In order to verify the desired safety properties, type inference is utilized. Type inference is split into four phases:

\begin{enumerate}
	\item First, input is read by the CIL, which is a front end for the C programming language that assists with program analysis and transformation. CIL will then output an abstract syntax tree representation that will be simplified to the static single assignment form to guarantee that each variable is assigned exactly once.
	\item Second, physical types will be generated for each declared function and global variable which will be verified with the source files.
	\item Third, the abstract syntax tree generated by CIL will be walked and associate each expression and variable with a refinement type that has a distinct refinement variable that represents its unknown refinement predicate.  This phase also generates constraints such that when solving for the refinement variables we will get a correct solution.
	\item Lastly, the refinement variables are solved for using the constraints found in phase 3.
\end{enumerate}

In order to solve the found typing constraints CSolve utilizes the Z3 SMT solver.  A SMT problem is a decision problem for logical formulas with respect to combinations of background theories expressed in classical first-order logic with equality. The SMT solver was used to discharge the logical validity queries that arise in constraint solving through the use of SMT-based logical reasoning and type theory-based data structure reasoning. As a result, refinement type systems are easily able to reason and synthesis using facts about the contents of unbounded data structures.

In order to verify the safety of program code CSolve uses the refinement types found. Using these types, CSolve infers liquid types which is a refinement type whose refinement predicate is a conjunction of user-provided logical qualifiers. Logical Qualifiers are logic predicates ranging over the program variables, the wildcard "*",which CSolve instantiates with the names of program variables, and the value variable v, which stands for the value being described by the refinement type.

Using the extern keyword on a function will instruct CSolve that it is a global function and to use the passed type and omit the body of the function when processing other source files that make calls to the externalized global function. Bundled within CSolve are also a set of annotations that can be used within each program file to configure CSolve so that it will instruct it to process the annotated section in a certain manner.  

The input of CSolve is a C source code file and a file speciying the set of logical predicates to use in refinement inference. Contained within are a predefined set of predicates that have commonly proven useful. The output of CSolve will either be that a program is type-safe or a file delimited list of each error along with the type constraints that were violated from step three of the type inference process.

Since, the C intermediate language (CIL) is a hook directly into the compilation process of C source code, CSolve is also able to work with standard distributions of GCC with minor modifications to the build process.
\end{document}

